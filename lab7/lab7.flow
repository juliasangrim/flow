import lingo/pegcode/driver;
import string;
import ds/tree;
import fs/filesystem;
import ds/array;
import maybe;

ArExpr ::= ArSum, ArMult, ArSub, ArDiv, ArInv, ArInt, ArVar;
ArSub(lhs : ArExpr, rhs : ArExpr);
ArSum(lhs : ArExpr, rhs : ArExpr);
ArMult(lhs : ArExpr, rhs : ArExpr);
ArDiv(lhs : ArExpr, rhs : ArExpr);
ArInv(val : ArExpr);
ArInt(val : int);
ArVar(val : string);

s2ar(str : string) -> ArExpr {
	e_gr = "#include D:/repo/flow9/lab7/grammar.lingo";
	parsic(
			compilePegGrammar(e_gr), 
			str,
	SemanticActions(setTree(defaultPegActions.t,
     "createArInt", \s -> ArInt(s2i(s[0]))))
	 );
}

ar2str(expr : ArExpr) -> string {
	switch (expr) {
		ArInt(val) : i2s(val);
		ArSum(lhs, rhs) : concatStrings(["(", ar2str(lhs), "+", ar2str(rhs), ")"]);
		ArMult(lhs, rhs) : concatStrings(["(", ar2str(lhs), "*", ar2str(rhs), ")"]);
		ArSub(lhs, rhs) : concatStrings(["(", ar2str(lhs), "-", ar2str(rhs), ")"]);
		ArInv(val) : concatStrings(["-", ar2str(val)]);
		ArDiv(lhs, rhs) : concatStrings(["(", ar2str(lhs), "/", ar2str(rhs), ")"]);
		ArVar(val): val;
	}
}

calc(expr : ArExpr, tree : Tree) -> Maybe<double> {
	switch (expr) {
		ArInt(val) : Some(i2d(val));
		ArSum(lhs, rhs) : {
			lhs1 = calc(lhs, tree);
			rhs1 = calc(rhs, tree);
			if (lhs1 == None() || rhs1 == None()) {
				None();
			} else {
				Some(either(lhs1, 0.0) + either(rhs1, 0.0));
			}
		}
		ArMult(lhs, rhs) : {
			lhs1 = calc(lhs, tree);
			rhs1 = calc(rhs, tree);
			if (lhs1 == None() || rhs1 == None()) {
				None();
			} else {
				Some(either(lhs1, 0.0) * either(rhs1, 0.0));
			};
		}
		ArSub(lhs, rhs) : {
			lhs1 = calc(lhs, tree);
			rhs1 = calc(rhs, tree);
			if (lhs1 == None() || rhs1 == None()) {
				None();
			} else {
				Some(either(lhs1, 0.0) - either(rhs1, 0.0));
			}
		}
		ArInv(val) : {
			val1 = calc(val, tree);
			if (val1 == None()) {
				None();
			} else {
				Some(0.0 - either(val1, 0.0));
			}
		}
		ArDiv(lhs, rhs) : {
			lhs1 = calc(lhs, tree);
			rhs1 = calc(rhs, tree);
			if (lhs1 == None() || rhs1 == None() || either(rhs1, 0.0) == 0.0) {
				None();
			} else {
				Some(either(calc(lhs, tree), 0.0) / either(calc(rhs, tree), 0.0));
			}
		}
		ArVar(val): lookupTree(tree, val);
	}
}


inf2RPN(expr : ArExpr) -> List<string> {
    switch (expr) {
        ArInt(val) : makeList1(i2s(val));
        ArSum(lhs, rhs) : concatList(concatList(inf2RPN(lhs),  inf2RPN(rhs)), makeList1("+"));
        ArMult(lhs, rhs) : concatList(concatList(inf2RPN(lhs),  inf2RPN(rhs)), makeList1("*"));  
		ArSub(lhs, rhs) : concatList(concatList(inf2RPN(lhs),  inf2RPN(rhs)), makeList1("-"));
		ArInv(val) : concatList(inf2RPN(val), makeList1("n")); 
		ArDiv(lhs, rhs) : concatList(concatList(inf2RPN(lhs),  inf2RPN(rhs)), makeList1("/"));
		ArVar(val) : makeList1(val);
		}

}

RPN2ar(expr : List<string>) -> ArExpr {
	listAt(
	foldList(expr, makeList(), \stack, i -> {
		if (i == "+") {
				Cons(
						ArSum(listAt(stack, 1, ArInt(0)), 
						listAt(stack, 0, ArInt(0))), 
				tailList(tailList(stack)));
		} else if (i == "*") {
				Cons(
						ArMult(listAt(stack, 1, ArInt(0)), 
						listAt(stack, 0, ArInt(0))), 
					tailList(tailList(stack)));
		} else if (i == "-") {
			Cons(
					ArSub(listAt(stack, 1, ArInt(0)), 
						listAt(stack, 0, ArInt(0))), 
					tailList(tailList(stack)));
		} else if (i == "n") {
			Cons(
				ArInv(listAt(stack, 0, ArInt(0))),
				tailList(stack));
		}  else if (i == "/") {
			Cons(
					ArDiv(listAt(stack, 1, ArInt(0)), 
						listAt(stack, 0, ArInt(0))), 
					tailList(tailList(stack)));
		} else if (isDouble(i) == false) {
			Cons(ArVar(i), stack);
		}
		else {
			Cons(ArInt(s2i(i)), stack);
		}
		}), 0, ArInt(0));
}

calcRPN(expr : List<string>, tree : Tree) -> Maybe<double> {
	listAt(
	foldList(expr, makeList(), \stack, i -> {
		if (i == "+") {
			lhs1 = listAt(stack, 1, None());
			rhs1 = listAt(stack, 0, None());
			if (lhs1 == None() || rhs1 == None()) {
				Cons(None(),
				tailList(tailList(stack)));
			} else {
				Cons(Some(either(lhs1, 0.0) + either(rhs1, 0.0)),
				tailList(tailList(stack)));
			}
		} else if (i == "*") {
			lhs1 = listAt(stack, 1, None());
			rhs1 = listAt(stack, 0, None());
			if (lhs1 == None() || rhs1 == None()) {
				Cons(None(),
				tailList(tailList(stack)));
			} else {
				Cons(Some(either(lhs1, 0.0) * either(rhs1, 0.0)),
				tailList(tailList(stack)));
			}
		} else if (i == "-") {
			lhs1 = listAt(stack, 1, None());
			rhs1 = listAt(stack, 0, None());
			if (lhs1 == None() || rhs1 == None()) {
				Cons(None(),
				tailList(tailList(stack)));
			} else {
				Cons(Some(either(lhs1, 0.0) - either(rhs1, 0.0)),
				tailList(tailList(stack)));
			}
		} else if (i == "/") {
			lhs1 = listAt(stack, 1, None());
			rhs1 = listAt(stack, 0, None());
			if (lhs1 == None() || rhs1 == None() || either(rhs1, 0.0) == 0.0) {
				Cons(None(),
				tailList(tailList(stack)));
			} else {
				Cons(Some(either(lhs1, 0.0) / either(rhs1, 0.0)),
				tailList(tailList(stack)));
			}
		} else if (i == "n") {
			val = listAt(stack, 0, None());
			if (val == None()) {
				Cons(None(),
				tailList(tailList(stack)));
			} else {
				Cons(Some(0.0 - either(val, 0.0)),
				tailList(stack));
			}
		} else if (isDouble(i) == false) {
			Cons(lookupTree(tree, i), stack);
		}
		else {
			Cons(Some(s2d(i)), stack);
		}
		}), 0, None());
	
}

printRPN(rpn : List<string>) -> void {
	foldList(rpn, makeList(), \stack, i -> {
		if (i == "n") {
			print("-");
		} else { 
			print(i);
		}
		print(" ");
		tailList(stack);
	});
	print("\n");
}


main() {
	//todo add variables
	s = getFileContent("test.txt");
    tree = s2ar(s);
	var = fold(getAllUrlParametersArray(), makeTree(), \tree1, array -> {
			setTree(tree1, array[0], s2d(array[1]));
	});
	println("Expression: ");
	println(s);
	println("Expression to tree: ");
    println(tree);
	println("Resolve inf form: ");
	res = calc(tree, var);
	if (res == None()) {
		println("Devision by 0 or no such variable");
	} 
	else {
		println(either(res, 0.0));
	}
    println("Inf to RPN: ");
    rpn = inf2RPN(tree);
    printRPN(rpn);
	println("RPN to inf :");
    println(ar2str(RPN2ar(rpn)));
	println("Resolve rpn form: ");
	resRPN = calcRPN(rpn, var);
	if (resRPN == None()) {
		println("Devision by 0 or no such variable");
	} 
	else {
		println(either(resRPN, 0.0));
	}
}